import { NextRequest, NextResponse } from 'next/server';

import { Innertube } from 'youtubei.js';

interface SubtitleLanguage {
  languageCode: string;
  languageName: string;
  isTranslatable: boolean;
  isAutoGenerated: boolean;
}

interface VideoInfo {
  videoId: string;
  title: string;
  duration: number;
  viewCount: number;
  channelName: string;
}

interface SubtitleData {
  index: number;
  startTime: number;
  endTime: number;
  text: string;
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const videoId = searchParams.get('videoId');

    if (!videoId) {
      return NextResponse.json({ error: 'videoId parameter is required' }, { status: 400 });
    }

    const yt = await Innertube.create();
    const videoInfo = await yt.getInfo(videoId);

    if (!videoInfo) {
      return NextResponse.json({ error: 'Video not found' }, { status: 404 });
    }

    // 기본 비디오 정보
    const video: VideoInfo = {
      videoId: videoInfo.basic_info.id || videoId,
      title: videoInfo.basic_info.title || 'No title',
      duration: videoInfo.basic_info.duration || 0,
      viewCount: Number(videoInfo.basic_info.view_count) || 0,
      channelName: videoInfo.basic_info.author || 'Unknown',
    };

    // 사용 가능한 자막 트랙 가져오기
    const captionTracks = videoInfo.captions?.caption_tracks || [];

    if (captionTracks.length === 0) {
      return NextResponse.json({
        video,
        languages: [],
        subtitles: {},
        message: 'No subtitles available for this video',
      });
    }

    // 사용 가능한 언어 목록
    const languages: SubtitleLanguage[] = captionTracks.map((track) => ({
      languageCode: track.language_code,
      languageName: track.name?.text || track.language_code,
      isTranslatable: true,
      isAutoGenerated: track.kind === 'asr', // ASR = Auto Speech Recognition
    }));

    // 자막 데이터 가져오기
    let transcriptData;
    try {
      transcriptData = await videoInfo.getTranscript();
    } catch (error) {
      console.error('Error getting transcript:', error);
      return NextResponse.json({
        video,
        languages,
        subtitles: {},
        message: 'Transcript not available',
      });
    }

    const subtitles: Record<string, SubtitleData[]> = {};

    const transcript = transcriptData.transcript;

    if (transcript) {
      const content = transcript.content;
      const initialSegments = content?.body?.initial_segments || [];

      const subtitleItems: SubtitleData[] = initialSegments.map((segment, i) => ({
        index: i + 1,
        startTime: Number(segment.start_ms) / 1000,
        endTime: Number(segment.end_ms) / 1000,
        text: segment.snippet?.text || '',
      }));

      const currentLanguageCode = languages[0]?.languageCode || 'en';
      subtitles[currentLanguageCode] = subtitleItems;
    }

    return NextResponse.json({
      video,
      languages,
      subtitles,
    });
  } catch (error) {
    console.error('Error fetching YouTube data:', error);

    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : 'Failed to fetch video information',
      },
      { status: 500 }
    );
  }
}
